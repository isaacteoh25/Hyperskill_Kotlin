type: edu
custom_name: stage6
files:
- name: src/seamcarving/Main.kt
  visible: true
  text: |-
    package seamcarving

    import java.awt.Color
    import java.awt.image.BufferedImage
    import java.io.File
    import java.util.Stack
    import javax.imageio.ImageIO
    import kotlin.math.pow
    import kotlin.math.sqrt

    var INPUT_IMAGE = ""
    var OUTPUT_IMAGE = ""

    fun main(args: Array<String>) {
        if (commandsOkay(args)) saveImage(seamHorizontal())
    }

    fun commandsOkay(args: Array<String>): Boolean {
        for (i in args.indices) {
            val last = i == args.lastIndex

            when (args[i]) {
                "-in" -> if (last || !File(args[i + 1]).isFile) {
                    println("${args[i + 1]} is not a file.")
                    return false
                } else INPUT_IMAGE = args[i + 1]
                "-out" -> if (last) {
                    println("A filename was not given.")
                    return false
                } else try {
                    File(args[i + 1]).writeText("")
                    OUTPUT_IMAGE = args[i + 1]
                } catch (e: Exception) {
                    println(
                            "There was an error in writing to your file. Please ensure it is not set to read only or open" +
                                    "in another program."
                    )
                }
            }
        }
        if (INPUT_IMAGE == "") println("Missing -in image filename to invert color of.")
        if (OUTPUT_IMAGE == "") println("Missing -out filename to save the negative image.")
        return !(INPUT_IMAGE == "" || OUTPUT_IMAGE == "")
    }

    fun seamHorizontal() = rotateImage(seam(rotateImage(ImageIO.read(File(INPUT_IMAGE)))))

    fun seam(bImage: BufferedImage = ImageIO.read(File(INPUT_IMAGE))): BufferedImage {
        val energy = energy(bImage)
        var lowestBottom = Double.MAX_VALUE
        var seamTotal: Double
        var oldSeamTotal = Double.MAX_VALUE
        val stack = Stack<Int>()
        val oldStack = Stack<Int>()
        val jLast = energy[0].lastIndex
        val iLast = energy.lastIndex
        val setRed = { i: Int, j: Int -> bImage.setRGB(i, j, Color(255, 0, 0).rgb) }

        for (j in 1..jLast) {
            for (i in 0..iLast) {
                var add = energy[i][j - 1]
                if (i != 0 && energy[i - 1][j - 1] < add) add = energy[i - 1][j - 1]
                if (i != iLast && energy[i + 1][j - 1] < add) add = energy[i + 1][j - 1]
                energy[i][j] += add
                if (j == jLast && energy[i][j] < lowestBottom) lowestBottom = energy[i][j]
            }
        }

        for (i in 0..energy.lastIndex) {
            if (energy[i][jLast] == lowestBottom) {
                stack.push(i)
                seamTotal = energy[i][jLast]
                var index = i
                for (j in jLast - 1 downTo 0) {
                    var lowIndex = index
                    if (index != 0 && energy[index - 1][j] < energy[index][j]) lowIndex -= 1
                    if (index != iLast && energy[index + 1][j] < energy[lowIndex][j]) lowIndex = index + 1
                    index = lowIndex
                    stack.push(index)
                    seamTotal += energy[index][j]
                }
                if (seamTotal < oldSeamTotal) {
                    if (oldStack.isNotEmpty()) oldStack.clear()
                    oldSeamTotal = seamTotal
                    oldStack.addAll(stack)
                }
                stack.clear()
            }
        }

        for (j in 0..jLast) setRed(oldStack.pop(), j)

        return bImage
    }

    fun energy(bImage: BufferedImage): Array<Array<Double>> {
        val energy = Array(bImage.width) { Array(bImage.height) { 0.0 } }

        for (i in 0 until bImage.width) {
            for (j in 0 until bImage.height) {
                val x = if (i == 0) 1 else if (i == bImage.width - 1) bImage.width - 2 else i
                val y = if (j == 0) 1 else if (j == bImage.height - 1) bImage.height - 2 else j
                val left = Color(bImage.getRGB(x - 1, j))
                val right = Color(bImage.getRGB(x + 1, j))
                val up = Color(bImage.getRGB(i, y - 1))
                val down = Color(bImage.getRGB(i, y + 1))
                val xDif = (left.red.toDouble() - right.red).pow(2) +
                        (left.green.toDouble() - right.green).pow(2) + (left.blue.toDouble() - right.blue).pow(2)
                val yDif = (up.red.toDouble() - down.red).pow(2) +
                        (up.green.toDouble() - down.green).pow(2) + (up.blue.toDouble() - down.blue).pow(2)
                val energyNum = sqrt(xDif + yDif)
                energy[i][j] = energyNum
            }
        }

        return energy
    }

    fun rotateImage(bImage: BufferedImage): BufferedImage {
        val bImage2 = BufferedImage(bImage.height, bImage.width, BufferedImage.TYPE_INT_RGB)

        for (i in 0 until bImage.width) {
            for (j in 0 until bImage.height) bImage2.setRGB(j, i, Color(bImage.getRGB(i, j)).rgb)
        }

        return bImage2
    }

    fun saveImage(image: BufferedImage) = ImageIO.write(image, "png", File(OUTPUT_IMAGE))
  learner_created: false
- name: test.kt
  visible: true
  text: |-
    package seamcarving

    ////object ByteArrayToImage {
    ////    @Throws(Exception::class)
    ////    @JvmStatic
    //    fun main(args: Array<String>) {
    //        val bImage = ImageIO.read(File("sample.png"))
    //        val bos = ByteArrayOutputStream()
    //        ImageIO.write(bImage, "png", bos)
    //        val data = bos.toByteArray()
    //        val bis = ByteArrayInputStream(data)
    //        val bImage2 = ImageIO.read(bis)
    //        ImageIO.write(bImage2, "png", File("out.png"))
    //        println("image created")
    //    }
    ////}
  learner_created: false
- name: Image.kt
  visible: true
  text: |-
    package seamcarving

    import java.awt.Color
    import java.awt.image.BufferedImage

    class Image {
        val height: Int
        val width: Int
        private val data: Array<Array<Color>>

        constructor(img: BufferedImage) {
            this.height = img.height
            this.width = img.width
            this.data = Array(height) { y -> Array(width) { x -> Color(img.getRGB(x, y)) } }
        }

        constructor(height: Int, width: Int) {
            this.height = height
            this.width = width
            this.data = Array(height) { Array(width) { Color.BLACK } }
        }

        constructor(source: Image) {
            this.height = source.height
            this.width = source.width
            this.data = Array(height) { y -> Array(width) { x -> source.getColor(x, y) } }
        }

        fun getColor(x: Int, y: Int) = data[y][x]

        fun setColor(x: Int, y: Int, c: Color) {
            data[y][x] = c
        }

        fun toBufferedImage() = BufferedImage(width, height, BufferedImage.TYPE_INT_RGB).apply {
            for (y in 0 until height) {
                for (x in 0 until width) {
                    setRGB(x, y, getColor(x, y).rgb)
                }
            }
        }

        fun transposed() = Image(width, height).also { res ->
            for (y in 0 until height) {
                for (x in 0 until width) {
                    res.setColor(y, x, getColor(x, y))
                }
            }
        }
    }
  learner_created: false
- name: test/SeamCarvingTest.java
  visible: false
  text: |
    import org.apache.commons.codec.binary.Hex;
    import org.hyperskill.hstest.testcase.TestCase;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;

    import javax.imageio.ImageIO;
    import java.awt.image.BufferedImage;
    import java.io.ByteArrayOutputStream;
    import java.io.File;
    import java.io.FileInputStream;
    import java.io.IOException;
    import java.security.MessageDigest;
    import java.security.NoSuchAlgorithmException;
    import java.util.Arrays;
    import java.util.List;

    class CheckFailException extends Exception {
        public CheckFailException(String s) {
            super(s);
        }
    }

    class OutFile {
        String hash;
        String filename;
        int width;
        int height;

        OutFile(String filename, int width, int height, String hash) {
            this.filename = filename;
            this.width = width;
            this.height = height;
            this.hash = hash;
        }

        public boolean compareWithActualMD5() throws CheckFailException {
            try {
                File imgPath = new File(filename);
                BufferedImage sourceImage = ImageIO.read(imgPath);

                BufferedImage rgbImage =
                    new BufferedImage(sourceImage.getWidth(), sourceImage.getHeight(), BufferedImage.TYPE_INT_RGB);
                for (int i = 0; i < sourceImage.getWidth(); i++) {
                    for (int j = 0; j < sourceImage.getHeight(); j++) {
                        rgbImage.setRGB(i, j, sourceImage.getRGB(i, j));
                    }
                }

                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                ImageIO.write(rgbImage, "bmp", baos);

                MessageDigest md = MessageDigest.getInstance("MD5");
                md.update(baos.toByteArray());
                byte[] digest = md.digest();
                String actualHash = Hex.encodeHexString(digest);
                if (!actualHash.equalsIgnoreCase(hash)) {
                    throw new CheckFailException(
                        String.format(
                            "Hash sum of your image (%s) does not match expected value",
                            actualHash));
                }
            } catch (IOException e) {
                throw new CheckFailException(
                    String.format(
                        "Could not read output file '%s'. Please check you produce output file",
                        filename));
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
                throw new CheckFailException("Internal test error. please report to Hyperskill team");
            }

            return true;
        }

        public boolean compareActualDimensions() throws CheckFailException {
            try {
                BufferedImage image = ImageIO.read(new File(filename));

                if (image == null) {
                    throw new CheckFailException(
                        String.format(
                            "File format error. Looks like your output '%s' is not a valid image file.",
                            filename));
                }

                if (image.getWidth() != width) {
                    throw new CheckFailException(
                        String.format(
                            "Dimensions mismatch. Output image width: %d; expected width: %d",
                            image.getWidth(), width));
                }

                if (image.getHeight() != height) {
                    throw new CheckFailException(
                        String.format(
                            "Dimensions mismatch. Output image height: %d; expected height: %d",
                            image.getHeight(), height));
                }

            } catch (IOException e) {
                throw new CheckFailException(
                    String.format(
                        "Could not read output file '%s'. Please check you produce output file",
                        filename));
            }

            return true;
        }
    }

    public class SeamCarvingTest extends StageTest<OutFile> {

        @Override
        public List<TestCase<OutFile>> generate() {

            return Arrays.asList(
                new TestCase<OutFile>()
                    .addArguments(
                        "-in", "test/small.png",
                        "-out", "test/small-reduced.png",
                        "-width", "1",
                        "-height", "1")
                    .setAttach(new OutFile(
                        "test/small-reduced.png", 14, 9,
                        "3e0266a991347682591a4955c9b2dd8e"))
                    .setTimeLimit(2 * 60 * 1000),

                new TestCase<OutFile>()
                    .addArguments(
                        "-in", "test/blue.png",
                        "-out", "test/blue-reduced.png",
                        "-width", "125",
                        "-height", "50")
                    .setAttach(new OutFile(
                        "test/blue-reduced.png", 375, 284,
                        "e73c04ad79d30ebef82b27f35b71dd92"))
                    .setTimeLimit(2 * 60 * 1000),

                new TestCase<OutFile>()
                    .addArguments(
                        "-in", "test/trees.png",
                        "-out", "test/trees-reduced.png",
                        "-width", "100",
                        "-height", "30")
                    .setAttach(new OutFile(
                        "test/trees-reduced.png", 500, 399,
                        "65603cba81d3ee6dedeeb5777d6665c5"))
                    .setTimeLimit(2 * 60 * 1000)
            );
        }

        @Override
        public CheckResult check(String reply, OutFile expectedFile) {
            try {
                expectedFile.compareActualDimensions();
                //expectedFile.compareWithActualMD5();
            } catch (CheckFailException e) {
                return CheckResult.wrong(e.getMessage());
            }

            return CheckResult.correct();
        }
    }
  learner_created: false
- name: test/blue.png
  visible: false
  learner_created: false
- name: test/small.png
  visible: false
  learner_created: false
- name: test/trees.png
  visible: false
  learner_created: false
- name: src/seamcarving/ImageRotation.kt
  visible: true
  learner_created: true
- name: src/seamcarving/Arguments.kt
  visible: true
  learner_created: true
- name: src/seamcarving/SeamCarving.kt
  visible: true
  learner_created: true
- name: src/seamcarving/sky-energy.png
  visible: true
  learner_created: true
- name: src/seamcarving/sky-horizontal-seam.png
  visible: true
  learner_created: true
- name: src/seamcarving/sky.png
  visible: true
  learner_created: true
- name: src/seamcarving/sky-reduced.png
  visible: true
  learner_created: true
- name: src/seamcarving/sample.png
  visible: true
  learner_created: true
- name: src/seamcarving/al
  visible: true
  learner_created: true
- name: src/seamcarving/sky_negative.png
  visible: true
  learner_created: true
- name: src/seamcarving/out.png
  visible: true
  learner_created: true
- name: src/seamcarving/sky-seam.png
  visible: true
  learner_created: true
- name: src/seamcarving/al.jpg
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/100/stages/555/implement#comment
status: Solved
record: 5
